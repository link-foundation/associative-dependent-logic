# Dependent Types in Links Notation
# Demonstrating how types are just links — "everything is a link"
#
# This example shows how the core of dependent type systems like
# Lean 4 and Rocq (Coq) can be expressed in LiNo.

# === Universe Hierarchy ===
# (Type 0) : (Type 1) : (Type 2) : ...
(Type 0)
(Type 1)

# === Define Types as Links ===
# Types are just links with type annotations
# Prefix type notation: (SubType: Type SubType)
(Natural: (Type 0) Natural)
(Boolean: (Type 0) Boolean)

# === Constructors using Prefix Type Notation ===
# (name: TypeName name) — the LiNo-native way to declare typed terms
(zero: Natural zero)
(true-val: Boolean true-val)
(false-val: Boolean false-val)

# Pi-types for function constructors
(succ: (Pi (Natural n) Natural))

# === Type Checking via Queries ===
# "Is zero of type Natural?" — querying the link network
(? (zero of Natural))
(? (Natural of (Type 0)))

# === Functions as Links ===
# Define identity function: identity(x) = x
(identity: lambda (Natural x) x)

# Apply identity function
(? (apply identity 0.7))

# === Type Queries ===
# "What is the type of x?"
(? (type of zero))

# === Combining Types with Probabilistic Logic ===
# The type system coexists with the probabilistic logic
((zero = zero) has probability 1)
(? (zero = zero))

# The liar paradox still works alongside types
(s: s is s)
((s = false) has probability 0.5)
(? (s = false))
